ARRAYS
=================================

XOr 

tc-O(n)
sc-O(n)

class Complete{
    
   
    // Function for finding maximum and value pair
    public static int[] game_with_number (int arr[], int n) {
        // Complete the function
        int [] xorf=new int[arr.length];
      for(int i=0;i<n-1;i++){
        //  arr[i]=arr[i]^arr[i+1];
        int cur=arr[i];
        int next=arr[i+1];
        xorf[i]=cur^next;
      }
      //return arr;
      xorf[n-1]=arr[n-1];
      return xorf;
    }
    
    
}



Optimised way
=====================


tc-O(n)
space-O(1)

class Complete{
    
   
    // Function for finding maximum and value pair
    public static int[] game_with_number (int arr[], int n) {
        // Complete the function
        
      for(int i=0;i<n-1;i++){
         arr[i]=arr[i]^arr[i+1];
      }
      return arr;
     
    }
    
    
}



-------------------------------------------------------------------------------------------------------------------------------------------






Subarray with given sum
========================================

Brute Force Approach
=================================





class Solution
{
    //Function to find a continuous sub-array which adds up to a given number.
    static ArrayList<Integer> subarraySum(int[] arr, int n, int s) 
    {
        
     
        // Your code here
        ArrayList<Integer>ar=new ArrayList<>();
        
        
            for(int i=0;i<n;i++){
//ArrayList<Integer>ar=new ArrayList<>();
              
                int first=i+1;
                int last=i;
                
                int sum=0;
              
                for(int j=i;j<n;j++){
                     sum=sum+arr[j];
                     last=last+1;
                    
                    if(sum==s){
                        ar.add(first);
                        ar.add(last);
                        return ar;
                    }
                    
                    if(sum>s){
                        break;
                    }
                    
                  
                }
            }
            
    
                ar.add(-1);
            
        return ar;    
        }
        
    
}




Optimised solution
================================

TC-O(N)
SC-O(N)

    int l=0;
      int r=0;
      int sum=0;
      int flag=0;
      while( r<n){
          sum=sum+arr[r];
          if(sum==s){
              ar.add(l+1);
              ar.add(r+1);
              flag=1;
              break;
          }
          else{
            if(sum>s){
            
                r=l+1;
                l++;
                sum=0;
                
            }
            else{
                r++;
            }
            }
      }
      
      
          if(flag==0){
              ar.add(-1);
              return ar;
          }
      
      
          else
          return ar;
      
        
        }
        
    
}




















Missing Number
==============================

Classical approach
tc-O(n)
space-1
but overflow problem



class Solution {
    int MissingNumber(int array[], int n) {
        // Your Code Here
      //  int size=array.length+1;
        int sum=(n*(n+1))/2;
        for(int i=0;i<n-1;i++){
           sum= sum-array[i];
        }
        return sum;
    }
}




Optimised soln
=========================
tc=0(N)
sc=1
no overflow problem


class Solution {
    int MissingNumber(int array[], int n) {
        // Your Code Here
  
    
    int x1=0,x2=0;
    for(int i=1;i<=n;i++){
        x1=x1^i;
    }
    
    for(int i=0;i<n-1;i++){
        x2=x2^array[i];
    }
    
    
    return x1^x2;
    
    }
}


-------------------------------------------------------------------------------------------------------------------






Finding duplicates
=========================

using comparision ==
-------------------------------------
tc-O(nlogn)
space-O(n)


class Solution {
    public static ArrayList<Integer> duplicates(int arr[], int n) {
        // code here
      //  ArrayList<Integer> dup=new ArrayList<>();
        HashSet<Integer>set=new HashSet<>();
        Arrays.sort(arr);
        for(int i=0;i<n-1;i++){
           // for(int j=i+1;j<n;j++){
                if(arr[i]==arr[i+1]){
                    set.add(arr[i]);
                }
            }
        
        ArrayList<Integer> dup=new ArrayList<>(set);
        Collections.sort(dup);
      if(dup.size()>0){
          return dup;
      }
      
      dup.add(-1);
      return dup;
    }
}



using xor
----------------------------

tc-O(nlogn)
space-O(n)


class Solution {
    public static ArrayList<Integer> duplicates(int arr[], int n) {
       
      //  ArrayList<Integer> dup=new ArrayList<>();
        HashSet<Integer>set=new HashSet<>();
        Arrays.sort(arr);
        for(int i=0;i<n-1;i++){
           
                if((arr[i]^arr[i+1])==0){
                    set.add(arr[i]);
                }
            }
        
        ArrayList<Integer> dup=new ArrayList<>(set);
        Collections.sort(dup);
      if(dup.size()>0){
          return dup;
      }
      
      dup.add(-1);
      return dup;
    }
}







Sort 0's,1's,2's
==========================================


TC-O(n^2)
sc-0(1)

class Solution
{
    public static void sort012(int a[], int n)
    {
        // code here 
        for(int i=0;i<n;i++){
            int x=a[i];
            for(int j=i+1;j<n;j++){
                if(x>a[j]){
                    a[i]=a[j];
                    a[j]=x;
                    x=a[i];
                }
            }
        }
    }
}


Optimised way
========================
DUTCH NATIONAL FLAG ALGO
TC-O(n)
sc-O(1)

3 pointer appoach



class Solution
{
    public static void sort012(int a[], int n)
    {
        // code here 
        int low=0;
        int mid=0;
        int high=n-1;
        while(mid<=high){
            if(a[mid]==0){
                int x=a[mid];
                a[mid]=a[low];
                a[low]=x;
                mid++;
                low++;
            }
            else{
            
            if(a[mid]==1){
                mid++;
            }
            
            else/*(a[mid]==2)*/{
                int x=a[mid];
                a[mid]=a[high];
                a[high]=x;
                high--;
                
            }
            }
        }
      
    }
}





Get PairCount
==================================

Brute Force















Optimised using map
==============================================


















Leaders in an Array
=================================

T.C-O(N)
SC-o(N)

class Solution{
    //Function to find the leaders in the array.
    static ArrayList<Integer> leaders(int arr[], int n){
        // Your code here
        ArrayList<Integer>lead=new ArrayList<Integer>();
        int max=0;
        for(int i=n-1;i>=0;i--){
            if(max<=arr[i]){
                max=arr[i];
                lead.add(arr[i]);
            }
        }
        
        Collections.reverse(lead);
        return lead;
    }
}



--------------------------------------------------------------------------



Largest subarray with 0 sum
=====================================

brute force
================
 TC-O(N^2)
 SC-O(1)



class GfG
{
    int maxLen(int arr[], int n)
    {
        // Your code here

        int count2=0;
        for(int i=0;i<n;i++){
            int sum=0;
            int k;
            int count1=0;
            for(int j=i;j<n;j++)
            {
          
                sum=sum+arr[j];
                k=sum;
                count1=count1+1;
                if(k==0){
                   
                    if(count2<count1){
                       count2=count1;
                }
                }
            }
        }
        
        return count2;
    }
}









Optimised approach
=======================

TC-O(N)
SC-O(N)



class GfG
{
    int maxLen(int arr[], int n)
    {
        // Your code here
       int max=0;
       int sum=0;
       
       HashMap<Integer,Integer> map=new HashMap<Integer,Integer>();
       
       for(int i=0;i<n;i++)
       {
           sum=sum+arr[i];
           if(sum==0 && i==0){
                 
                     max=i+1;
                     }
                 
                 
            if(sum==0){
                int temp=i+1;
                if(max<temp){
                    max=temp;
                }
            }     
                 
            if(map.containsKey(sum)){
                int temp=i-map.get(sum);
                if(max<temp){
                    max=temp;
                }
            }  
            else{
                 
            map.put(sum,i);
             }
       }
             return max;
           }
       }
    



-----------------------------------------------------------------------------------

Find triplet with given sum //////////vvvvvvvvimp
========================================

O(n^2)
O(n)

class Solution
{
   
	public boolean findTriplets(int arr[] , int n)
    {
      
        for(int i=0;i<n-2;i++){
         HashSet<Integer>set=new HashSet<>();
            int x=0-arr[i];   /////////IF SUM 0 THEN 0 
                  -
        for(int j=i+1;j<n;j++){
            int y=x-arr[j];
            if(set.contains(y)){
                return true;
            }
            else{
                set.add(arr[j]);
            }
                       
        }
        }
        return false;
        
        
    }
}



Reverse aray into K group subarray
============================================================


TC-O(n^2)
SC-O(1)

class Solution {
    //Function to reverse every sub-array group of size k.
    void reverseInGroups(ArrayList<Integer> arr, int n, int k) {
        // code here
        
        for(int i=0;i<n;i=i+k){
            int st=i;
            int en=Math.min(i+k-1,n-1);
            while(st<en){
               int temp=arr.get(st);
               arr.set(st,arr.get(en));
               arr.set(en,temp);
               st++;
               en--;
            }
        }
        
    }
}







Check whether elements of array are palindrome
=================================================================


class GfG
{
	public static int palinArray(int[] a, int n)
           {
                  //add code here.
                  
                for(int i=0;i<n;i++){
                  int  dup=0;
                  int pa=a[i];
                    while(a[i]!=0){
                        dup=dup*10+a[i]%10;
                        a[i]=a[i]/10;
                    }
                    
                    if(dup!=pa){
                        return 0;
                    }
                } 
                return 1;
           }
           
}


Implement stack using array
===========================================



class MyStack
{
    int top;
	int arr[] = new int[1000];

    MyStack()
	{
		top = -1;
	}
	
	//Function to push an integer into the stack.
    void push(int a)
	{
	    // Your code here
	    top=top+1;
	    arr[top]=a;
	    
	    
	} 
	
    //Function to remove an item from top of the stack.
	int pop()
	{
        // Your code here
        if(top==-1){
            return -1;
        }
        int ele=arr[top];
        top=top-1;
        return ele;
	}
	


Array contains subset of another array
==========================================================

class Compute {
    public String isSubset( long a1[], long a2[], long n, long m) {
        
      /*  HashMap<Long,Integer> map=new HashMap<>();
        for(int i =0;i<n;i++){
            if(map.containsKey(a1[i])){
                map.put(a1[i],map.get(a1[i])+1);
                }
                else{
                map.put(a1[i],1);
            }
        }
        
        
        for(int i=0;i<m;i++){
            if(!map.containsKey(a2[i])){
                return "No";
            }
            else{
                if(map.get(a2[i])>=1){
                    map.put(a2[i],map.get(a2[i]-1));
                }
                else{
                    return "No";
                }
            }
        }
        return "Yes";
        
        */
        
        ArrayList<Long> a=new ArrayList<>();
        for(int i=0;i<n;i++){
            a.add(a1[i]);
        }
        
        for(int i=0;i<m;i++){
            if(a.contains(a2[i])){
                a.remove(a2[i]);
            }
            else{
                return "No";
            }
        }
        
        
        
        
        
        
        return "Yes";
        
        
        
        
        
        
        
        
        
        
        
    }
}







Smallest subarray with sum greater than x
=====================================================

Brute force
TC-O(n^2)
SC-O(n)





class Solution {

    public static int smallestSubWithSum(int a[], int n, int x) {
        // Your code goes here 
        ArrayList<Integer>array=new ArrayList<Integer>();
        for(int i=0;i<n;i++){
            int count=1;
            int sum=a[i];
            int k=i+1;
            if(sum>x){
                return 1;
                
            }
            while(k<n){
                sum=sum+a[k];
                count=count+1;
                
                if(sum>x)
                {
                    array.add(count);
                    break;
                }
                k++;
            }
        }
        
      Collections.sort(array);
      return array.get(0);
        
    }
}


---------------------------------------------------------------------------
optimised solution
TC-O(N)
SC-O(1)


class Solution {

    public static int smallestSubWithSum(int a[], int n, int x) {
        // Your code goes here 
      int start=0;
      int end=0;
      int count=0;
      int sum=0;
      int minLength=Integer.MAX_VALUE;
      while(end<n){
          sum=sum+a[end];
          count=count+1;
          if(sum>x && start==end){
              minLength=1;
          }
          else{
          if(sum>x){
              minLength=Math.min(count,minLength);
              start=start+1;
              end=start;
              count=0;
              sum=0;
          }
          else{
              end++;
          }
      }
        
    }
    return minLength;
    }
}




===============================================================================================================


Remove duplicates from given string
===================================================

T.C-O(N)
S.C-O(N)

class Solution {
    String removeDuplicates(String str) {
        // code here
        ArrayList<Character> ar=new ArrayList<Character>();
       String x="";
        for(int i=0;i<str.length();i++){
             char ch=str.charAt(i);
            if(!ar.contains(ch))
         {   ar.add(ch);
            x=x+str.charAt(i);
            
        }
        }
        
        return x;
    }
}



Product array puzzle

Given an array nums[] of size n, construct a Product Array P (of same size n) such that P[i] is equal to the product of all the elements of nums except nums[i].

=================================================================================================================================================================

TC-O(N^2)
SC-O(N)

class Solution 
{ 
	public static long[] productExceptSelf(int nums[], int n) 
	{ 
        // code here
        long[] arr=new long[n];
        for(int i=0;i<n;i++){
        int start=0;
        int end=0;
        long mul=1;
        for(int j=end;j<n;j++){
            if(j!=i){
                mul=mul*nums[j];
            }
            
        }
        
        arr[i]=mul;
        }
        return arr;
	} 
} 



First negative number in an array of window size k
=========================================
TC-O(N^2)


class Compute {
    
    public long[] printFirstNegativeInteger(long A[], int N, int K)
    {
        //ArrayList<Integer>ar=new ArrayList<Integer>();
        long [] ar=new long[N];
        //int start=0;
        for(int i=0;i<N-1;i++){
           int start=i;
            int end=i+K-1;
            while(start<=end){
                if(A[start]<0){
                    ar[i]=A[start];
                    break;
                }
                else{
                if(A[start]>0 && start==end){
                    ar[i]=0;
                   
                    }
                    else{
                    start++;
                }
            }
            }
           
        }
        return ar;
    }
}








Optimised solution
==================================
TC-O(N)
SC-O(K)




class Compute {
    
    public long[] printFirstNegativeInteger(long A[], int N, int K)
    {
        
        long [] ar=new long[N-(K-1)];
        //int start=0;
        int start=0;
        //int i=0;
        int end=0;
        while(start<ar.length){
        
        if(A[end]<0){
            if(end>=start){
                ar[start]=A[end];
                start++;
                continue;
            }
        }
        
        if(end==start+K-1){
            ar[start]=0;
            start++;
        }
        
        
        
        end++;
        }
        return ar;

        
    }
}




Largest sum contiguous Subarray  (V.V.V.V.V.V.IMP)  Kadane algorithm

==================================================
TC-O(N)
SC-O(1)


class Solution{

    // arr: input array
    // n: size of array
    //Function to find the sum of contiguous subarray with maximum sum.
    long maxSubarraySum(int arr[], int n){
        
        // Your code here
        
        long cursum=0;
      //  long maxsum=arr[0];
        long maxsum=0;        

        for(int i=0;i<n;i++){
          cursum=cursum+arr[i];
          if(cursum>maxsum){
              maxsum=cursum;
          }
          if(cursum<0){
              cursum=0;
          }
        
    }
    return maxsum;
    }
    
}




MAXIMUM JUMP  (V.V.V.P)
=======================================
tc-O(n)
sc-O(1)



class Solution{
    static int minJumps(int[] arr){
        // your code here
        
     
         int halt=0,max=0,jump=0;
         if(arr[0]==0 && halt==arr.length-1){
             return 0;
         }
         if(arr[0]==0){
             return -1;
         }
         
         if(arr[0]==arr.length-1){
             return 1;
         }
         
         for(int i=0;i<arr.length;i++){
             max=Math.max(max,i+arr[i]);
             
             if(arr[i]==0){
                 return -1;
             }
             if(max>=arr.length-1){
                 jump=jump+1;
                 return jump;
             }
             
             if(i==halt){
                 halt=max;
                 jump=jump+1;
                 
             }
         }
 
 
     return jump;
 
     
    }
}


-------------------------------------------------------------------------------------------------------------------------------

class Solution{
    //Function to find the days of buying and selling stock for max profit.
    ArrayList<ArrayList<Integer> > stockBuySell(int A[], int n) {
        // code here
        //  ArrayList<Integer> ar=new ArrayList<Integer>();
           ArrayList<ArrayList<Integer>> ans=new ArrayList<ArrayList<Integer>>();
        int buy=0,flag=0,sell=0;
        for(int i=1;i<n;i++){
            if(A[i]>=A[i-1] && A[i]!=A[buy] ){
                sell++;
                flag=1;
                
                
            }
            else{
                if(buy==sell){
                    buy=i;
                    sell=i;
                }
            
            else{
                ArrayList<Integer> ar=new ArrayList<Integer>();
                ar.add(A[buy]);
                ar.add(A[sell]);
                ans.add(ar);
                buy=i;
                sell=i;
            }
            
            }
        }
        if(flag==0){
            return ans;
        }
        else{
         // ArrayList<Integer> ar=new ArrayList<Integer>();
           if(buy<n-1 && sell==n-1){
                 ArrayList<Integer> ar=new ArrayList<Integer>();
            ar.add(A[buy]);
            ar.add(A[sell]);
            ans.add(ar);
        }
        }
        
        
        return ans;
    }
}
----------------------------------------------------------------------------------------------------------------------------------------------------





Kth smallest element in an array

Time limited exceeded.


class Solution{
    public static int kthSmallest(int[] arr, int l, int r, int k) 
    { 
        //Your code here
        while(l<r){
            if(arr[l]<arr[r]){
                if(arr[r]<arr[r-1]){
                    int temp=arr[r];
                    arr[r]=arr[r-1];
                    arr[r-1]=temp;
                }
                else{
                    if( r+1<arr.length && arr[r]>arr[r+1]){
                        int temp=arr[r];
                        arr[r]=arr[r+1];
                        arr[r+1]=temp;
                        r++;
                    }
                    else{
                        r--;
                    }
                }
            }
            
            
            else{
                int temp =arr[r];
                arr[r]=arr[l];
                arr[l]=temp;
            }
        }
        
        return arr[k-1];
        
    } 
}





Sorting approach
============================

class Solution{
    
    public static int partition(int[]arr,int pindx,int l,int r){
        
        int i=l-1;
        for(int j=l;j<r;j++){
            if(arr[j]<arr[pindx]){
                i++;
                int temp=arr[i];
                arr[i]=arr[j];
                arr[j]=temp;
            }
            
        }
        
        i++;
        int temp=arr[i];
        arr[i]=arr[pindx];
        arr[pindx]=temp;
            
    return i;    
        
    }
    
    
    public static int quicksort(int[] arr,int l,int r,int k){
         
         
        int pindx=arr[r];
        int pivot=partition(arr,pindx,l,r);
        if(k>pivot){
            return quicksort(arr,pivot+1,r,k);
        }
        else{
            if (k<pivot){
                return quicksort(arr,l,pivot-1,k);
            }
            else{
                return arr[pivot];
            }
        }
        
        
        
    }
    
    public static int kthSmallest(int[] arr, int l, int r, int k) 
    { 
        //Your code here
       return quicksort(arr,l,r,k-1);
        
    } 
}


















Optimised approach using priority queue
========================================================================


















Majority element
============================

TC-O(N)
SC-O(N)

class Solution
{
    static int majorityElement(int a[], int size)
    {
        // your code here
        HashMap<Integer,Integer>map=new HashMap<Integer,Integer>();
        if(size==0){
            return -1;
        }
        
        if(size==1){
            return a[0];
        }
        for(int i=0;i<size;i++){
            if(map.containsKey(a[i])){
                map.put(a[i],map.get(a[i]+1));
            }
            else{
            
            map.put(a[i],1);
        }
        }
        
        int n=size/2;
        //int max=-1;
        //int maxval=-1;
        
        for(int en:map.keySet()){
            if( n<map.get(en)){
                return en;
            }
            }
        
        
                   return -1;
        }
        
        
        
    
}










Boyer Moore Algorithm 
optimised algo
===================
TC-O(N)
SC-O(1)


class Solution
{
    static int majorityElement(int a[], int size)
    {
        // your code here
        int ans=0;
        int count=1;
         for(int i=1;i<size;i++){
             if(a[ans]==a[i]){
                 count++;
             }
             else{
                 count--;
             }
             
             if(count==0){
                 ans=i;
                 count=1;
             }
         }
         
         int n=size/2;
        int max=0;
         
         for(int i=0;i<size;i++){
             if(a[i]==a[ans]){
                 max++;
             }
             
         }
         if(max>n){
             return a[ans];
         }
         else{
             return -1;
         }
         
        }
        
        
        
    
}




Stack Permutation
============================================

TC=O(N)
SC=O(N)

class Solution {
    public static int isStackPermutation(int n, int[] ip, int[] op) {
        // code here
        Stack<Integer>A=new Stack<Integer>();
      //  Stack<Integer>B=new Stack<Integer>();
        int j=0;
       for(int i=0;i<n;i++){
           A.push(ip[i]);
          while(!A.isEmpty() && op[j]==A.peek()){
              A.pop();
              j++;
              
          }
         
       }
       
        if(A.isEmpty()){
            return 1;
        }
        else{
            return 0;
        }
    }
}
            







Zero Sum Subarray
=====================================

TC-O(N^2)
SC-O(1)



class Solution{
    //Function to count subarrays with sum equal to 0.
    public static long findSubarray(long[] arr ,int n) 
    {
        //Your code here
        long count=0;
        
        for(int i=0;i<n;i++){
            long sum=0;
            for(int j=i;j<n;j++){
                sum=sum+arr[j];
                if(sum==0){
                    count=count+1;
                }
            }
        }
        
        return count;
    }
}


optimised soln
========================
TC-O(N)
SC=O(N)


class Solution{
    //Function to count subarrays with sum equal to 0.
    public static long findSubarray(long[] arr ,int n) 
    {
    HashMap<Long,Integer> map=new HashMap<Long,Integer>();
    long sum=0,count=0;
    map.put(sum,1);
    
    for(int i=0;i<n;i++){
        sum=sum+arr[i];
        if(map.containsKey(sum)){
            count=count+map.get(sum);
            map.put(sum,map.get(sum)+1);
        }
        else{
            
        map.put(sum,1);
        }
    }
     
     return count;
    }
}



Celebrity Problem
========================================
TC-O(N^2)
SC-O(1)


class Solution
{ 
    //Function to find if there is a celebrity in the party or not.
    int celebrity(int M[][], int n)
    {
    	// code here 
    	int i=0;
    	int j=0;
    	int indx=-1;
    	for( i=0;i<n;i++){
    	   int count=0;
    	   
    	   for(j=0;j<n;j++){
    	       if(M[i][j]==0){
    	           count++;
    	       }
    	   }
    	   
    	   if(count ==n){
    	      indx=i;
    	   }
    	}
    	
    	
    	if(indx==-1){
    	    return -1;
    	}
    	
    	for(i=0;i<n;i++){
    	  if(i!=indx){
    	    if(M[i][indx]==0 )
    	
    	      return -1;
    	  }
    	}
    	return indx;
    }
}


















tc=O(N)
SC=O(N)



class Solution
{ 
    //Function to find if there is a celebrity in the party or not.
    int celebrity(int M[][], int n)
    {
    	// code here 
        Stack<Integer>st=new Stack<Integer>();
        for(int i=0;i<n;i++){
            st.push(i);
        }
        
        while(st.size()>=2){
            int x=st.pop();
            int y=st.pop();
            
            if(M[x][y]==1)
            {
                st.push(y);
            }
            else{
                st.push(x);
            }
        }
        
        int cel=st.pop();
        for(int i=0;i<n;i++){
            if(i!=cel){
            if(M[cel][i]==1 || M[i][cel]==0){
                return -1;
            }
            }
       
        }
        return cel;
    }
}





Spiral taversal in array

t(r*C)


class Solution
{
    //Function to return a list of integers denoting spiral traversal of matrix.
    static ArrayList<Integer> spirallyTraverse(int matrix[][], int r, int c)
    {
        // code here 
        int minrow=0;
        int mincol=0;
        int maxrow=r-1;
        int maxcol=c-1;
        int count=0;
        int t=r*c;
       ArrayList<Integer> spiral=new ArrayList<Integer>();
        
        while(count<t){
            
           // if(mincol>maxcol || minrow>maxrow){
             //   
               // return ;
            //}
            
            for(int i=minrow, j=mincol;j<=maxcol && count<t;j++ ){
                spiral.add(matrix[i][j]);
                count++;
            }
            minrow++;
            
            for(int i=minrow, j=maxcol;i<=maxrow && count<t;i++){
                spiral.add(matrix[i][j]);
                count++;
            }
            maxcol--;
            
            for(int i=maxrow, j=maxcol;j>=mincol && count<t;j--){
                spiral.add(matrix[i][j]);
                count++;
            }
            maxrow--;
        
            for(int i=mincol, j=maxrow;j>=minrow && count<t;j--){
                spiral.add(matrix[j][i]);
                count++;
            }
            
            mincol++;
            
        }
        return spiral;
    }
}




Swap and Maximise
==========================
Given an array a[ ] of N elements. Consider array as a circular array i.e. element after an is a1. The task is to find maximum sum of the absolute difference between consecutive elements with rearrangement of array elements allowed i.e. after any rearrangement of array elements find |a1 – a2| + |a2 – a3| + …… + |an-1 – an| + |an – a1|.

class GFG
{
    long maxSum(long arr[] ,int n)
    {
        
        Arrays.sort(arr);
        long []ar=new long[n];
        int l=0;
        int h=n-1;
        int i=0;
        while(l<=h){
            if(l==h){
                ar[i]=arr[l];
                l++;
            }
            
            else{
                ar[i++]=arr[l++];
                ar[i++]=arr[h--];
                }
        }
        long sum=0;
        for( i=0;i<n;i++){
            
            if(i==n-1){
                sum=sum+Math.abs(ar[i]-ar[0]);
            }
            else
            sum=sum+Math.abs(ar[i]-ar[i+1]);
            
        }
        
        return sum;
    }
}











Count inversion
===========================



class Solution
{
    // arr[]: Input Array
    // N : Size of the Array arr[]
    //Function to count inversions in the array.
    
    static long mergesort(long arr[],long s,long mid,long end ){
        long count=0;
        long [] ar=new long[arr.length];
        
        int x=(int)s;
        int y=(int)mid+1;
        int k=0;
        
        while(x<=mid && y<=end){
            if(arr[x]<=arr[y]){
                ar[k]=arr[x];
                k++;
                x++;
            }
            else{
                ar[k]=arr[y];
                count+=mid-x+1;
                k++;
                y++;
            }
            
            
        }
        
        
        while(x<=mid)
        {
            ar[k]=arr[x];
            k++;
            x++;
        }
        
         while(y<=end)
        {
            ar[k]=arr[y];
            k++;
            y++;
        }
        
        k=0;
        for(int i=(int)s;i<=end;i++){
         arr[i]=ar[k++];
          //  k++;
        }
        
       return count;
    }
    
    static long merge(long arr[],long s,long e){
        long count=0;
        long mid=s+(e-s)/2;
        if(s<e){
        count+=merge(arr,s,mid);
         count+=merge(arr,mid+1,e);
       count+= mergesort(arr,s,mid,e);
        }
    return count;
    }
    
    static long inversionCount(long arr[], long N)
    {
        
    return    merge(arr,0,N-1);
















MERGE K SORTED ARRAYS
=============================


MIN HEAP METHOD

class Pair implements Comparable<Pair>{
    int val;     // actual value 
    int arridx;  // for index of kth array in matrix
    int idx;     // for index of element in an kth array
    public Pair(int val,int arridx,int idx){
        this.val = val;
        this.arridx = arridx;
        this.idx = idx;
    }
    public int compareTo(Pair neW){ // To always get minimum value Pair at peek of PQ.
        return this.val-neW.val;
    }
}
class Solution
{
    //Function to merge k sorted arrays.
    public static ArrayList<Integer> mergeKArrays(int[][] arr,int K) 
    {
        ArrayList<Integer> ans = new ArrayList<>();
        PriorityQueue<Pair> pq  = new PriorityQueue<>();
        for(int i = 0;i<K;i++){
            pq.offer(new Pair(arr[i][0],i,0));
        }
        while(!pq.isEmpty()){
            Pair tmp = pq.remove();
            ans.add(tmp.val);
            tmp.idx++;
            if(tmp.idx<K && tmp.arridx< K){
                pq.offer(new Pair(arr[tmp.arridx][tmp.idx],tmp.arridx,tmp.idx));
            }
        }
        return ans;
    }
}
    
    
        
        
        
        
    }
}





K Largest element
==========================================

TC-O(NlogN+N)
SC-O(N)


class Solution {
    
    int [] reverse(int [] arr){
        
        int n=arr.length;
        for(int i=0;i<n/2;i++){
            int temp=arr[i];
            arr[i]=arr[n-i-1];
            arr[n-i-1]=temp;
        }
        
        return arr;
    }
    
    
    
    int[] kLargest(int[] arr, int n, int k) {
        // code here
        int[] a=new int[k];
        Arrays.sort(arr);
        reverse(arr);
        for(int i=0;i<k;i++){
            a[i]=arr[i];
        }
        
        return a;
    }
}




----------------------------------------------


WE CAN OPTIMISE IT TO KlogK+K
usign Priority queue




class Solution {
    
    
    int[] kLargest(int[] arr, int n, int k) {
        // code here
        PriorityQueue<Integer> pq=new PriorityQueue<Integer>();
        int[] ar=new int[k];
        for(int i=0;i<k;i++){
            pq.offer(arr[i]);
        }
        
        for(int i=k;i<n;i++){
            if(arr[i]>pq.peek()){
                pq.poll();
                pq.add(arr[i]);
            }
        }
        
        for(int i=k-1;i>=0;i--){
            ar[i]=pq.poll();
        }
       return ar; 
    }




Minimum Sum  (using string sum)
================================



class Solution {
    String sum(String x,String y){
        int carry=0;
       // int sum=0;
        String res="";
        int i=x.length()-1;
        int j=y.length()-1;
        while(i>=0 || j>=0|| carry!=0){
        int ival=i>=0?x.charAt(i)-'0':0;
        int jval=j>=0? y.charAt(j)-'0':0;
        int sum=ival+jval+carry ;
        res=(sum%10)+res;
        carry=sum/10;
        i--;
        j--;
        }
        return res;
    }
    
    String solve(int[] arr, int n) {
        // code here
       String x="";
       String y="";
        
        Arrays.sort(arr);
        for(int i=0;i<n;i++){
            if(i%2==0){
            if(arr[i]==0 && x.length()==0)
               continue;
               
               
               x=x+String.valueOf(arr[i]);
                
            }
            
            else{
                
                if(arr[i]==0 && y.length()==0)
                   continue;
                y=y+String.valueOf(arr[i]);
            }
        }
        
        return sum(x,y);
    }
}
}



MATRICES
=================

class Solution {
    int rowWithMax1s(int arr[][], int n, int m) {
        // code here
        int i=0;
        int j=m-1;
        int count=0;
        int maxcount=0;
        int indx=-1;
        
        while(i<n && j>=0){
            
            if(arr[i][j]==1){
                count++;
                 if(j==0 && count==m){
                     indx=i;
            }
                j--;
                
            }
            else{
                if(maxcount<count){
                    maxcount=count;
                    indx=i;
                }
                
                i++;
                count=0;
                j=m-1;
            }
            
           
                
                
        }
        return indx;
        
    }
}








COUNT SORT
==================================

Sort the string
===========================



class Solution
{
    //Function to arrange all letters of a string in lexicographical 
    //order using Counting Sort.
    public static String countSort(String arr)
    {
        // code here
        
        int[] countfrequency=new int[26];
        char[] answer=new char[arr.length()];
        
        for(int i=0;i<arr.length();i++){
            countfrequency[arr.charAt(i)-'a']++;
        }
        
        int sum=0;
        for(int i=0;i<26;i++){
            sum+=countfrequency[i];
            countfrequency[i]=sum;
        }
        
        
        
        for(int i=0;i<arr.length();i++){
            
            int indx=arr.charAt(i)-'a';
            int count=countfrequency[indx];
            answer[count-1]=arr.charAt(i);
            countfrequency[indx]=count-1;
            
        }
        
        String ss=String.valueOf(answer);
        return ss;
    }
}







Minimum Platforms
=============================


n = 6 
arr[] = {0900, 0940, 0950, 1100, 1500, 1800}
dep[] = {0910, 1200, 1120, 1130, 1900, 2000}



class Solution
{
    //Function to find the minimum number of platforms required at the
    //railway station such that no train waits.
    static int findPlatform(int arr[], int dep[], int n)
    {
        // add your code 
      Arrays.sort(arr);
      Arrays.sort(dep);
      int a=0;
      int d=0;
      int maxplatform=0;
      int c=0;
      while(a<n && d<n){
          if(arr[a]<=dep[d]){
              c++;
              a++;
          }
          else{
              c--;
              d++;
          }
          
          maxplatform=Math.max(maxplatform,c);
      }
      
      return maxplatform;
        
    }
    
}



Shortest path 1 to n
===========================
Class Solution{
    
    
    
    static int minStep(int n){
        //complete the function here
        
        int count=0;
        while(n>1){
            if(n%3==0){
                n=n/3;
                count++;
            }
            else{
                n--;
                count++;
            }
        }
        
        return count;
    }
}



Frogs and jumps
============================


//corner case: 2 2 2 2  2
//you must not repeat the loop for this


class Solution {
    public int unvisitedLeaves(int N, int leaves, int frogs[]) {
        // Code here
        int[] visited=new int[leaves];
        
        int frog=0;
        int count=0;
        for(int i=0;i<frogs.length;i++){
            
        if(frogs[i]<=leaves && visited[frogs[i]-1]==0){    
           while(frog<leaves){
                frog=frog+frogs[i];
                
                if(frog<=leaves && visited[frog-1]==0){
                    visited[frog-1]=1;
                    count++;
                }
            }
            
            frog=0;
        }
        
        
        }
        return leaves - count;
    }
}



Minimum Number of Arrows to Burst Balloons

class Solution {
    public int findMinArrowShots(int[][] points) {
        
        Arrays.sort(points,(a,b)->
            Integer.compare(a[1],b[1])
        );


        int arrow=1;
        int comp=points[0][1];
        for(int[] point:points){

            if(point[0]>comp){
                arrow++;
                comp=point[1];
            }
            else{
                continue;
            }
        }

        return arrow;
    }
}








Merge Intervals:
class Solution {
    public int[][] merge(int[][] intervals) {
        Arrays.sort(intervals,(a,b)->Integer.compare(a[0],b[0])); //sort the array
        int start=intervals[0][0];  //starting pnt of frst indx
        int end=intervals[0][1];    //ending pnt of first indx
        List<int[]>arr=new ArrayList<>();   
        for(int[] interval:intervals){  
            if(interval[0]<=end){    //if starting interval less than ending
                if(end<=interval[1]){   //checkif the previous end is smaller/larger than present end
                    end=interval[1];
                }
                
            }
            else{
                arr.add(new int[]{start,end});   // add in the array
                // arr.add(end);
                start=interval[0];  //updte new strt nd end
                end=interval[1];
            }
        }

        arr.add(new int[]{start,end});
        return arr.toArray(new int[arr.size()][2]);
    }
}

